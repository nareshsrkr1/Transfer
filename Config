CREATE TABLE directory_sizes (
    id INT IDENTITY(1,1) PRIMARY KEY,
    hostname VARCHAR(255),
    app_name VARCHAR(255),
    sub_app_name VARCHAR(255),
    path VARCHAR(255),
    size_formatted VARCHAR(20),  -- Changed data type to VARCHAR
    used_space_formatted VARCHAR(20),  -- Changed data type to VARCHAR
    available_space_formatted VARCHAR(20),  -- Changed data type to VARCHAR
    last_updated DATETIME DEFAULT GETDATE()
);

def save_to_db(results):
    conn = pyodbc.connect(Constants.Connection)
    cursor = conn.cursor()

    try:
        for result in results:
            app_name, sub_app_name, path, size, used_space, available_space = result
            # Format size, used space, and available space with appropriate extensions
            size_formatted = format_bytes(size)
            used_space_formatted = format_bytes(used_space) if used_space is not None else None
            available_space_formatted = format_bytes(available_space) if available_space is not None else None
            cursor.execute('''INSERT INTO directory_sizes (hostname, app_name, sub_app_name, path, size_formatted, used_space_formatted, available_space_formatted, last_updated)
                              VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)''', (hostname, app_name, sub_app_name, path, size_formatted, used_space_formatted, available_space_formatted))
        conn.commit()
        print("Data inserted successfully.")
    except pyodbc.Error as e:
        print("Data insertion failed:", e)
    finally:
        conn.close()

def format_bytes(bytes):
    if bytes is None:
        return None
    elif bytes >= 1024 ** 3:  # Gigabytes
        return f"{round(bytes / (1024 ** 3), 2)} GB"
    elif bytes >= 1024 ** 2:  # Megabytes
        return f"{round(bytes / (1024 ** 2), 2)} MB"
    else:  # Bytes
        return f"{bytes} bytes"
